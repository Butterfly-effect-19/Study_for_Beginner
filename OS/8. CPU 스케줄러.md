# CPU 스케줄러

---

### CPU 스케줄링 목적

> CPU의 스케줄링의 목적은 `응답시간`이나 `처리량`, `효율성`을 증대시키기 위해 **CPU가 다음에 실행할 프로세스를 선택하는 것**이라 할 수 있다.
> 
- **공평성** : 모든 프로세스가 자원을 공평하게 배정받아야 하며, 특정 프로세스가 배제되어서는 안 된다.
- **효율성** : 시스템 자원을 놀리는 시간 없이 스케줄링해야 한다.
- **안정성** : 우선순위를 사용하여 중요한 프로세스가 먼저 처리되도록 해야 한다.
- **반응 시간 보장** : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.
- **무한 연기 방지** : 특정 프로세스의 작업이 무한히 연기되어서는 안 된다.

## 스케줄링 시 고려사항

### 1. 선점형 vs 비선점형

|구분|선점형|비선점형|
|------|---|---|
|작업방식|실행 상태에 있는 작업을 중단시키고 새로운 작업을 실행할 수 있다|실행 상태에 있는 작업이 완료될 때 까지 다른 작업이 불가능 하다|
|장점|프로세스가 CPU를 독점할 수 없어 대화형이나 시분할 시스템에 적합하다|CPU 스케줄러의 작업량이 적고 문맥 교환의 오버헤드가 적다|
|단점|문맥 교환의 오버헤드가 많다|기다리는 프로세스가 많아 처리율이 떨어진다|
|사용|시분할 방식 스케줄러에 사용된다|일괄 작업 방식 스케줄러에 사용된다|
|중요도|높다|낮다|

### 2. CPU 집중 프로세스 vs I/O 집중 프로세스

> 대부분의 CPU 스케줄러는 우선순위를 사용한다. 우선순위가 있다는 것은 프로세스의 중요도가 다르다는 의미이다.  CPU를 할당받아 실행하면 CPU burst, 입출력 작업을 하면 I/O burst라고 한다.
> 

<aside>
💡 burst time : 쉬지않고 CPU를 할당했을 때의 예상 처리 시간

</aside>

- **CPU bound process(CPU 집중 프로세스)** : 실행하는 동안 입출력은 자주 수행하지 않으면서 대부분의 시간을 어떤 계산을 하기 위해 CPU를 사용하는 프로세스를 의미한다. (계산 위주의 작업 수행)
- **I/O bound process(입출력 집중 프로세스)** : 실행 시간의 대부분을 CPU보다는 입출력을 위한 시간으로 사용하는 프로세스를 의미한다. (대화형 프로세스-입출력 중심)

두 프로세스가 같이 `대기상태`에 있다면 입출력 집중 프로세스에 먼저 CPU를 할당 시키는 것이 더 효율적이다. 왜냐하면 입출력 집중 프로세스는 CPU를 빠르게 쓰고 입출력 버스트를 하러 나가기 때문에 다른 프로세스가 오래 기다리지 않아도 된다.

### 3. 전면 프로세스 vs 후면 프로세스

- **전면 프로세스** : GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓여 현재 입출력이 사용되고, 사용자와 상호작용이 가능해 상호작용 프로세스라고도 불림 (워드 프로세스)
- **후면 프로세스** : 사용자의 입력 없이 작동하여 일괄 작업 프로세스라고 불림 (압축 프로세스)

전면 프로세스는 사용자의 요구에 즉각 반응해야 하지만 후면 프로세스는 그럴 필요가 없다. 따라서 **전면 프로세스를 먼저 처리**해 줘야 한다.

### 4. 프로세스 우선순위

CPU 스케줄러 대부분은 프로세스에 우선순위를 매겨 우선순위가 높은(우선순위 숫자가 작은) 프로세스부터 처리되도록 한다.

- 프로세스는 크게 커널 프로세스와 일반 프로세스로 나뉜다.
- 커널 프로세스의 우선순위가 일반 프로세스보다 높다
- 시스템에는 다양한 우선순위 프로세스가 공존하며 우선순위가 높은 프로세스가 CPU를 먼저, 더 오래 차지한다.
- 일반 프로세스의 우선순위는 사용자가 조절할 수 있으며 시스템에 따라 높은 숫자가 높은 우선순위를 나타내기도 하고 낮은 숫자가 높은 우선순위를 나타내기도 한다.
- 참고
    - 커널 프로세스 > 일반 프로세스
    - 전면 프로세스 > 후면 프로세스
    - 대화형 프로세스 > 일괄 처리 프로세스
    - 입출력 집중 프로세스 > CPU 집중 프로세스

## 스케줄링 알고리즘

### 1. 성능 척도(Scheduling Criteria)

스케줄링 알고리즘의 효율성을 파악하는 판단 기준이 있다. 주의해야 할 점은 작업을 마친다는 것이 하나의 프로세스가 종료된다는 것이 아니라 CPU의 입장에서 프로세스가 들어와 작업을 처리하고 나갔을 때를 말하는 것이다.

- CPU의 입장
    
    **CPU utilization(CPU 사용률) -** 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법으로 최대한 CPU를 바쁘게 만드는 것이다. 가장 이상적인 수치는 물론 100%다.
    
    **Throughput(처리량) -** 단위 시간당 작업을 마친 프로세스의 수다. 즉, CPU 버스트를 처리한 수다.
    
- 프로세스의 입장
    
    **Trun-around time(반환 시간) -** 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간이다. 프로세스의 대기 시간 + 실행시간이다. 여기서 대기 시간은 없을 수도 있고, 1 번일 수도, 여러 번일수도 있다.
    
    **Waiting time(대기 시간) -** 프로세스가 CPU를 할당 받아 실행되기 전 대기 상태일 때의 시간이다. 보통 준비 큐에서 대기를 하는 시간이다.
    
    **Response time(응답 시간)** - 프로세스가 대기 상태에 들어와 CPU를 최초로 얻기까지 걸리는 시간이다. 대기 시간과의 차이점은 대기 시간은 반환 시간과 마찬가지로 여러 번 있을 수 있다. 그 총합이 대기 시간이고, 응답 시간은 최초의 한 번이다. 이 응답 시간은 프로세스 입장에서 CPU를 한 번도 못 얻은 것과 한 번이라도 얻는 것은 사용자 응답에 있어서 중요한 차이가 있기 때문에 중요하다.
    

### 2. 알고리즘 종류

스케줄링 대상은 Ready Queue에 있는 프로세스들이다.

1. **FCFS (First Come First Served**)
    - 특징과 문제점
        
        특징
        
        - 먼저 온 고객을 먼저 서비스해주는 방식, 즉 먼저 온 순서대로 처리.
        - 비선점형(Non-Preemptive) 스케줄링일단 CPU를 잡으면 CPU burst 가 완료될 때까지 CPU를 반환하지 않는다. 할당되었던 CPU가 반환 될 때만 스케줄링이 이루어진다.
        
        문제점
        
        - `convoy effect` : 소요 시간이 긴 프로세스가 먼저 도달하여 효율성을 낮추는 현상이 발생한다.
2. **SJF(Shortest - Job - First**)
    - 특징과 문제점
        
        특징
        
        - 다른 프로세스가 먼저 도착했어도 CPU burst time 이 짧은 프로세스에게 선 할당
        - 비선점형(Non-Preemptive) 스케줄링
        
        문제점
        
        - `starvation` : 효율성을 추구하는 게 가장 중요하지만 특정 프로세스가 지나치게 차별 받으면 안되는 것이다. 이 스케줄링은 극단적으로 CPU 사용이 짧은 job을 선호한다. 그래서 사용 시간이 긴 프로세스는 거의 영원히 CPU를 할당 받을 수 없다.
        
        <aside>
        💡 (해결책) `aging` : 아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주자.
        
        </aside>
        
3. **SRTF(Shortest Remaining Time First)**
    - 특징과 문제점
        
        특징
        
        - 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
        - 선점형 (Preemptive) 스케줄링현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time 을 가지는 새로운 프로세스가 도착하면 CPU 를 뺏긴다.
        
        문제점
        
        - starvation
        - 새로운 프로세스가 도달할 때마다 스케줄링을 다시 하기 때문에 CPU burst time(CPU 사용 시간)을 측정할 수가 없다.
4. **Priority Scheduling**
    - 특징과 문제점
        
        특징
        
        - 우선순위가 가장 높은 프로세스에게 CPU 를 할당하는 스케줄링이다. 우선순위란 정수로 표현하게 되고 작은 숫자가 우선순위가 높다.
        - 선점형 스케줄링(Preemptive) 방식
            - 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU 를 선점한다.
        - 비선점형 스케줄링(Non-Preemptive) 방식
            - 더 높은 우선순위의 프로세스가 도착하면 Ready Queue 의 Head 에 넣는다.
        
        문제점
        
        - starvation
        - 무기한 봉쇄(Indefinite blocking) 실행 준비는 되어있으나 CPU를 사용 못하는 프로세스를 CPU 가 무기한 대기하는 상태
5. **Round Robin**
    - 특징과 장단점
        
        특징
        
        - 현대적인 CPU 스케줄링
        - 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 된다.
        - 할당 시간이 지나면 프로세스는 선점당하고 ready queue 의 제일 뒤에 가서 다시 줄을 선다.
        - `RR`은 CPU 사용 시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
        - `RR`이 가능한 이유는 프로세스의 context 를 save 할 수 있기 때문이다.
        
        장점
        
        - `Response time`이 빨라진다. n 개의 프로세스가 ready queue 에 있고 할당 시간이 q(time quantum)인 경우 각 프로세스는 q 단위로 CPU 시간의 1/n 을 얻는다. 즉, 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.
        - 프로세스가 기다리는 시간이 CPU 를 사용할 만큼 증가한다. 공정한 스케줄링이라고 할 수 있다.
        
        <aside>
        💡 주의할 점
        설정한 `time quantum`이 너무 커지면 `FCFS`와 같아진다. 또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch 로 overhead 가 발생한다. 그렇기 때문에 적당한 `time quantum`을 설정하는 것이 중요하다.
        
        </aside>
        
6. **Multilevel Queue (다단계 큐 스케줄링)**
    - 특징과 문제점
        
        특징
        
        - 우선순위에 따라 준비 큐를 여러 개 사용하는 방식
        - 우선순위가 높은 큐에 먼저 CPU가 할당되어 큐에 속한 모든 프로세스가 처리 되야 다음 우선순위 큐가 실행될 수 있다.
        - 한 번 우선순위가 매겨져 준비 큐에 들어가면 이 우선순위는 바뀌지 않는다.
        
        ![Untitled](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/8-1.png)
        
        문제점
        
        - starvation
        - 공평성 문제
7. **Multilevel Feedback Queue**
    - 특징
        - 다단계 큐의 공평성 문제를 완화하기 위해 신분 하락이 가능한 알고리즘이다. 이 알고리즘에서는 우선순위가 변동 되기 때문에 큐 사이의 이동이 가능하다.
        - 한 번 CPU를 할당 받은 프로세스는 우선순위가 조금 낮아진다. 따라서 더 낮은 큐로 이동하게 된다. (우선순위가 높아져 상위 큐로 이동할 수도 있다)
        - 그리고 더 보완하기 위해 우선순위가 높은 큐보다 우선순위가 낮은 큐에 타임 슬라이스 크기를 크게 준다. 어렵게 얻은 CPU를 좀 더 오랫동안 사용하게 해주기 위함이다.
        
        ![Untitled](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/8-2.png)
        

## 🔗 REFERENCE

- [CPU 스케줄링](https://bnzn2426.tistory.com/65)
- [CPU 스케줄링 개요](https://herong.tistory.com/entry/CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)