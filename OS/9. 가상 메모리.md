# 가상 메모리

상태: 준비
최종 편집 일시: 2021년 6월 4일 오전 11:21

- **목차**

# 가상 메모리의 개요

  **가상 메모리**는 물리 메모리의 크기와 상관없이 프로세스에 큰 메모리 공간을 제공하는 기술입니다.

- **메모리 관리자**가 사용할 수 있는 메모리의 전체 크기 = 물리 메모리 + 스왑 영역
- **동적 주소 변환(DAT)** : 가상 주소 → 물리 주소
- **매핑 테이블** : 가상 주소가 물리 메모리의 어느 위치에 있는지 알 수 있도록 정리한 표,

                             메모리 관리자는 가상 주소와 물리 주소를 일대일 매핑 테이블로 관리

![%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20fea147a9b83941dcb4a2e723aaae6971/Untitled.png](%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20fea147a9b83941dcb4a2e723aaae6971/Untitled.png)

        가상 메모리의 메모리 분할 방식에는 세그먼테이션, 페이징, 세그먼테이션-페이징 혼용 기법이 있습니다.

# 페이징 기법

 페이징 기법은 물리 주소 공간을 같은 크기로 나누어 사용하는 **고정 분할 방식**을 이용합니다.

- **페이지** : 가상 주소의 분할된 각 영역(Process를 자른 것)
- **프레임** : 물리 메모리의 분할된 각 영역

 페이지와 프레임의 크기는 같기 때문에 페이지는 어떤 프레임에도 배치될 수 있습니다.

- **페이지 테이블(PMT)** : 어떤 페이지가 어떤 프레임에 있는지에 대한 정보가 담겨있는 매핑 테이블.

## 페이징 기법의 주소 변환

$$VA = <P, D> → PA = <F, D>$$

- **VA** : 가상 주소 / **P** : 페이지 번호 / **D** : 페이지의 처음 위치에서 해당 주소까지의 거리
- **PA** : 물리 주소 / **F** : 프레임 번호 / **D** : 프레임의 처음 위치에서 해당 주소까지의 거리

페이지와 프레임의 크기가 같기 때문에 D는 변환 과정에서 바뀌지 않습니다.

## 페이지 테이블 매핑 방식

 스왑 영역에 페이지 테이블이 저장 될 때, 각 페이지 테이블의 시작 주소는 **페이지 테이블 기준 레지스터(PTBR)**에 보관됩니다.

![%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20fea147a9b83941dcb4a2e723aaae6971/Untitled%201.png](%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20fea147a9b83941dcb4a2e723aaae6971/Untitled%201.png)

- **직접 매핑**

    페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식

- **연관 매핑**

    페이지 테이블 전체를 스왑 영역에서 관리하는 방식, 물리 메모리의 공간이 작을 때 사용

    - **변환 색인 버퍼(TLB)** : 물리 메모리에 무작위로 저장된 페이지 테이블의 일부분

    - **문제점** : 원하는 프레임 번호를 얻기 위해선 **모든 테이블을 검색**해야 함

- **집합-연관 매핑**

    연관 매핑의 문제를 개선한 방식, 페이지 테이블을 일정한 집합으로 자르고 자른 덩어리 단위로 물리 메모리에 가져옴

    - **새로 생성한 집합 테이블(디렉터리 테이블)**에는 일정하게 자른 페이지 테이블이 물리 메모리에

      있는지, 스왑 영역에 있는지에 대한 정보 표시 

    - **I** (invalid) = TLB미스 = 물리 메모리에 원하는 테이블이 없음

    - 가상 주소를 **VA = <P1, P2, D>**로 바꾸어 표시→P1는 디렉터리 테이블, P2는 묶음에서의 위치

- **역매핑**

    위 방법들과 달리 **물리 메모리의 프레임 번호를 기준**으로 테이블을 구성, 물리 메모리의 프레임에 어떤 프로세스의 어떤 페이지가 올라와 있는지 표시

    - **장점** : 테이블의 크기가 매우 작음

    - **단점** : PID, 페이지 번호를 모두 알아야 함

# 세그먼테이션 기법

 세그먼테이션 기법은 물리 메모리를 프로세스의 크기에 따라 가변적으로 나누어 사용하는 **가변 분할 방식**을 이용합니다.

- **limit** : 세그먼트의 크기 (각 세그먼트는 자신에게 주어진 메모리 영역을 넘어가면 안됨)
- **address** : 물리 메모리 상의 시작 주소

※ 프로세스의 크기가 limit를 넘어가면 메모리 관리자가 해당 프로세스를 강제 종료함, 이때의 오류를 **트랩**이라고 함

![%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20fea147a9b83941dcb4a2e723aaae6971/Untitled%202.png](%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20fea147a9b83941dcb4a2e723aaae6971/Untitled%202.png)

             S : 세그먼트 번호, D : 세그먼트 시작 시점에서 해당 주소까지의 거리(distance)

## 세그먼테이션 기법의 장단점

- **장점** : 메모리를 프로세스 단위로 관리하기 때문에 페이지 테이블이 작고 단순
- **단점** : 물리 메모리의 외부 단편화로 인해 물리 메모리 관리가 복잡함

# 세그먼테이션-페이징 혼용 기법

 **사용자 입장**에서는 세그먼테이션 기법, **메모리 관리자 입장**에서는 페이징 기법을 사용하는 기법입니다.

![%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20fea147a9b83941dcb4a2e723aaae6971/Untitled%203.png](%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20fea147a9b83941dcb4a2e723aaae6971/Untitled%203.png)

             S : 세그먼트 번호, P : 페이지 번호, D : 페이지의 처음 위치에서 해당 주소까지의 거리(distance)

- **메모리 보호** 및 **중복 정보**를 세그먼테이션 테이블에서 관리함으로써 **메모리 관리를 효율적**으로 할 수 있음

# 참고🔗

- 쉽게 배우는 운영체제(한빛 아카데미) - 8장