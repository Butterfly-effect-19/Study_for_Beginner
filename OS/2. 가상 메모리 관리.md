# 가상 메모리 관리

## 01 요구 페이징

Paging : 고정 분할 방식으로 전체 프로그램을 Main Memory(MM, 주기억장치)에 로딩한다.

### 1. 요구 페이징(Demand Paging)의 개요

`요구 페이징` : 사용자가 요청할 때 해당 페이지를 메모리로 가져오는 것을 말한다.

**메모리 절약**, **메모리의 효율적 관리**, **프로세스의 응답 속도 향상** 등의 효과를 볼 수 있음.

- **프로세스의 일부만 메모리로 가져오는 이유**
    1. 일반적인 Paging 기법보다 **메모리를 효율적으로 관리하기 위해서** (메모리가 꽉 차면 관리하기 어려우므로 가급적 적은 양의 프로세스만 유지)
    2. **응답 속도를 향상 하기 위해서** (용량이 큰 프로세서를 전부 메모리로 가져와 실행하면 응답(`throught put 처리율`)이 늦어질 수 있으므로 필요한 모듈만 올려 실행)

로딩 되는 프로그램의 일부 페이지는 MM에 올리고 나머지는 스왑 영역에서 로딩한다.

프로세스 입장에서는 프로세스를 구성하는 모든 페이지가 한꺼번에 메모리로 올라오는 것이 좋다. 이렇게 프로세스를 구성하는 모든 페이지를 메모리에 올리는 것을 순수한 스와핑(swapping)이라고 한다. 이와 달리 사용자가 요구할 때 메모리에 올리는 것을 게으른 스와퍼(lazy swapper)라고 한다. 스와핑은 오버헤드가 많이 든다.

---

### 2. 페이지 테이블 엔트리의 구조

가상 메모리의 크기는 `물리 메모리`와 `스왑 영역`을 합친 것이다.

`스왑 영역`은 하드디스크에 존재하나 메모리 관리자가 관리하는 영역으로, 가상 메모리의 구성 요소 중 하나이다.

스왑 영역에서 물리 메모리로 데이터를 가져오는 것을 스왑인, 물리 메모리에서 스왑 영역으로 데이터를 내보내는 것을 스왑아웃이라고 한다.

![swapping](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/swapping.png)

- **페이지가 스왑 영역에 있는 경우**
    1. 요구 페이징으로 인해 처음부터 물리 메모리에 올라가지 못한 경우
    2. 메모리가 꽉 차서 스왑 영역으로 옮겨 온 경우

페이지 테이블 엔트리(PTE)의 구성

![pte](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/pte.png)

- 페이지 번호
- 프레임 번호
- 플래그 비트 (0 or 1)
    - 접근 비트 : 페이지가 메모리에 올라온 후 사용한 적이 있는지 알려주는 비트
    - 변경 비트 : 페이지가 메모리에 올라온 후 데이터의 변경이 있었는지 알려주는 비트
    - 유효 비트 : 페이지가 실제 메모리에 있는 지를 나타내는 비트
    - 읽기, 쓰기, 실행 비트 : 페이지에 대한 읽기, 쓰기, 실행 권한을 나타내는 비트

---

### 3. 페이지 부재

프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황을 말한다.

페이지 부재가 발생하면 프로세스가 해당 페이지를 사용할 수 있도록 스왑 영역에서 물리 메모리로 옮겨야 함.

가상 메모리의 페이지 테이블에는 페이지가 물리 메모리에 있는지, 스왑 영역에 있는지 표시하기 위해 `유효 비트`를 사용한다.

- 유효 비트가 0일 때 : 페이지가 메모리에 있으므로 주소 필드에 물리 **메모리의 프레임 번호**가 저장
- 유효 비트가 1일 때 : 페이지가 스왑 역영에 있으므로 주소 필드에 **스왑 영역 내 페이지의 주소**가 저장

- 페이지 부재 처리 과정

    ![page fault](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/page-fault.png)

`페이지 교체` : 페이지 부재가 발생하면 스왑 영역에 있는 페이지를 MM에 빈 영역에 

`페이지 교체(대치) 알고리즘` : 어떤 페이지를 스왑 영역으로 내보낼지 결정하는 알고리즘

`대상 페이지(victim page)` : 페이지 교체 알고리즘에 의해 스왑 영역으로 보낼 페이지 (=희생 페이지)

세그먼테이션 오류 : 사용자의 프로세스가 주어진 메모리 공간을 벗어나거나 접근 권한이 없는 곳에 접근할 때 발생하며 해당 프로세스를 강제 종료하여 해결

페이지 부재 : 해당 페이지가 물리 메모리에 없을 때 발생하는 오류. 사용자 프로세스와 무관하기 때문에 페이지 부재가 발생하면 메모리  관리자는 스왑 영역에서 해당 페이지를 물리 메모리로 옮긴 후  (swapping을 통해 해결) 작업을 진행. 오류로 보지 않음

---

### 4. 지역성

기억 장치에 접근하는 패턴이 메모리 전체에 고루 분포되는 것이 아니라 특정 영역에 집중되는 성질을 말한다.

1. 공간의 지역성 : 현재 위치에서 가까운 데이터에 접근할 확률이 먼 거리에 있는 데이터에 접근할 확률보다 높음
2. 시간의 지역성 : 현재를 기준으로 가장 가까운 시간에 접근한 데이터가 더 먼 시간에 접근한 데이터보다 사용될 확률이 높음
3. 순차적 지연성 : 여러 작업이 순서대로 진행되는 경향이 있음

---

## 02 페이지 교체 알고리즘

### 1. 페이지 교체 알고리즘의 개요

**스왑 영역으로 보낸 페이지를 결정하는 알고리즘**

메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정하여 페이지 부재를 줄이고 시스템의 성능을 향상

![page replace algoritm](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/page-replace-algorithm.png)

같은 메모리 접근 패턴을 사용하여 **페이지 부재 횟수**와 **페이지 성공 횟수**를 비교

---

### 2. 무작위 페이지 교체 알고리즘

스왑 영역으로 쫓아낼 대상 페이지를 특별한 로직 없이 무작위로 선정

지역성을 전혀 고려하지 않기 때문에 자주 사용하는 페이지가 대상 페이지로 선정되기도 하여 성능이 좋지 않음.

---

### 3. FIFO 페이지 교체 알고리즘

시간상으로 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정하여 스왑 영역으로 쫓아냄

무조건 오래된 페이지를 대상 페이지로 선정하기 때문에 성능이 떨어짐

![fifo](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/fifo.png)

---

### 4. 최적 페이지 교체 알고리즘

앞으로 사용하지 않을 페이지를 스왑 영역으로 옮김.

메모리가 앞으로 사용할 페이지를 미리 살펴보고 페이지 교체 선정 시점부터 사용 시점까지 가장 멀리 있는 페이지를 대상 페이지로 선정

**이상적인 방법이지만 실제로 구현할 수 없음**

**최적 근접 알고리즘** (구현이 가능하면서도 성능이 최적 페이지 교체 알고리즘에 근접한 방법, 미래의 접근 패턴을 추정)

- LRU (최소 사용 알고리즘) → 성능이 좋음
- LFU (최소 빈도 사용 알고리즘) → 성능이 좋지 않음
- NUR (최근 미사용 알고리즘)
- MFU (최대 사용 빈도 알고리즘) → 성능이 좋지 않음

---

### 5. LRU 페이지 교체 알고리즘

페이지에 접근한 시간을 기준으로 대상 페이지를 선정

- '최근 최소 사용 페이지 교체 알고리즘' 이라고도 함
- 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 스왑 영역으로 옮김
- 알고리즘은 시간을 기준으로 구현할 수 있으며 카운터나 참조 비트를 이용하는 방법도 있다.

- 페이지 접근 시간에 기반한 구현

    ![timestamp](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/timestamp.png)

- 카운터에 기반한 구현

    (단점)접근 시간을 기록하든 카운트를 하든 두 방법은 모두 추가적인 메모리 공간을 필요로 함.

- 참조 비트 시프트 방식

    각 페이지에 일정 크기의 참조 비트를 만들어 사용.

    페이지가 접근할 때마다 오른쪽으로 shift됨.

    ![reference bit](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/reference-bit.png)

주의!

메모리 접근 패턴을 변경하면 LRU 페이지 교체 알고리즘의 성능이 FIFO 페이지 교체 알고리즘만큼 느려지기도 하고 최적 페이지 교체 알고리즘만큼 좋아지기도 한다. 일반적으로 LRU 페이지 교체 알고리즘의 성능은 FIFO 페이지 교체 알고리즘보다 우수하고 최적 페이지 교체 알고리즘보다는 조금 떨어지는 것으로 알려져 있다.

---

### 6. LFU 페이지 교체 알고리즘

페이지가 사용된 횟수를 기준으로 대상 페이지를 선정

구현에 상당한 비용이 들고, 최적 페이지 교체 정책을 LRU만큼 제대로 구현해내지 못하기 때문에 실제 잘 쓰이지 않는다.

![lfu](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/lfu.png)

---

### 7. NUR 페이지 교체 알고리즘

LRU, LFU 페이지 교체 알고리즘과 성능이 거의 비슷하면서 불필요한 공간 낭비 문제를 해결한 알고리즘

- '최근 미사용 페이지 교체 알고리즘'이라고도 불림.
- 페이지마다 참조 비트와 변경 비트를 가짐
    - 참조 비트 : 페이지에 접근(read/execute)하면 1이 됨
    - 변경 비트 : 페이지가 변경(write/append)하면 1이 됨
- 모든 페이지의 초기 상태는 (0,0)
- 모두 (1,1)이면 초기화
- 같은 비트의 페이지가 여러 개라면 무작위로 대상 페이지를 선정

![nur](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/nur.png)

---

### 8. FIFO 변형 알고리즘

FIFO 페이지 교체 알고리즘의 방식을 기본으로 하되 페이지에 접근할 때마다 순서의 변화를 주어 성능을 향상한다.

- 2차 기회 페이지 교체 알고리즘(=2차 기회 FIFO 페이지 교체 알고리즘)

    FIFO와 마찬가지로 큐를 사용하지만, 특정 페이지에 접근하여 페이지 부재 없이 성공할 경우 해당 페이지를 큐의 맨 뒤로 옮김으로써 기회를 한 번 더 준다.

    최적 근접 알고리즘보다 성능이 약간 낮고, FIFO보다 약간 성능이 높음.

    큐를 유지하는 비용이 높고, 페이지가 성공하면 큐의 중간에 있는 값을 뒤로 이동하는 작업이 추가되는 것이 단점

    ![fifo2](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/fifo2.png)

- 시계 알고리즘

    원형 큐를 사용한다. 스왑 영역으로 옮길 대상 페이지를 가리키는 포인터를 사용한다.

    포인터가 큐의 맨 바닥으로 내려가면 다시 큐의 처음을 가리키게 된다.

    2차 기회 페이지 교체 알고리즘에 비해 각 페이지에 참조 비트가 하나씩 추가된다.

    참조 비트의 초깃값은 0, 메모리에 있는 페이지를 성공적으로 참조하면 0에서 1로 변경

    ![clock](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/clock.png)

---

## 03 스레싱과 프레임 할당

### 1. 스레싱

하드디스크의 입출력이 너무 많아져서 잦은 페이지 부재로 작업이 멈춘 것 같은 상태를 말한다.

스레싱 발생 시점

- CPU가 작업하는 시간보다 스왑 영역으로 페이지를 보내고 새로운 페이지를 메모리에 가져오는 작업이 빈번해져서 CPU가 작업할 수 없는 상태(노는)에 이르게 되는 시점
- 물리 메모리의 크기를 늘리면 스레싱 발생 지점이 늦춰져서 프로세스를 원만하게 실행할 수 있음.

    ![threshing](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/threshing.png)

프레임 할당

- 프로세스에 너무 적은 프레임을 할당하면 페이지 부재가 빈번히 일어남
- 프로세스에 너무 많은 프레임을 할당하면 페이지 부재가 줄지만 메모리가 낭비됨
- 프로세스에 프레임을 할당하는 방식은 {`정적 할당`, `동적 할당`}

---

### 2. 정적 할당

프로세스 실행 초기에 프레임을 나누어준 후 그 크기를 고정하는 방식이다.

- 균등 할당

    프로세스의 크기와 상관없이 사용 가능한 프레임을 모든 프로세스에 동일하게 할당

    크기가 큰 프로세스의 경우 필요한 만큼 프레임을 할당 받지 못하기 때문에 페이지 부재가 빈번하게 발생

- 비례 할당

    프로세스의 크기에 비례하여 프레임을 할당

    2가지 문제

    - 프로세스가 실행 중에 필요로 하는 프레임을 유동적으로 반영하지 못함
    - 사용하지 않을 메모리를 처음부터 미리 확보하여 공간을 낭비

---

### 3. 동적 할당

프로세스를 실행하는 중에 프레임을 나누어주기도 하고 회수하기도 하는 방식이다.

- 작업 집합 모델

    지역성 이론을 바탕으로 하며, 가장 최근에 접근한 프레임(페이지)이 이후에도 또 참조될 가능성이 높다는 가정에서 출발

    최근 일정 시간 동안 참조된 페이지들을 집합으로 만들고, 이 집합에 있는 페이지들을 물리 메모리에 유지

    - 작업 집합 크기 : 작업 집합 모델에서 물리 메모리에 유지할 페이지 크기
    - 작업 집합 윈도우 : 작업 집합에 포함되는 페이지 범위
    - 작업 집합 갱신 : 페이지가 작업 크기만큼 접근할 때마다 작업 집합을 갱신

        ![work-set](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/work-set.png)

    작업 집합 윈도우를 너무 크게 잡으면 필요 없는 페이지가 메모리에 남아서 다른 프로세스에 영향을 미침

    윈도우를 너무 적게 잡으면 필요한 페이지가 스왑 영역으로 옮겨져서 프로세스의 성능이 떨어짐

- 페이지 부재 빈도

    페이지 부재 횟수를 기록하여 페이지 부재 비율을 계산하는 방식

    페이지 부재 비율이 상한선을 초과하면 프레임을 추가하여 늘림

    페이지 부재 비율이 하한선 밑으로 내려가면 할당한 프레임을 회수

    페이지 부재 빈도 방식은 프로세스를 실행하면서 추가적으로 페이지를 할당하거나 회수하여 적정 페이지 할당량을 조절

    ![frequency](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/frequency.png)

---

## 04 [심화학습] 프레임 관련 이슈

### 1. 전역 교체와 지역 교체

`전역 교체` : 전체 프레임을 대상으로 교체 알고리즘을 적용

`지역 교체` : 현재 실행 중인 프로세스의 프레임을 대상으로 교체 알고리즘을 적용

- 장점 : 자신에게 할당된 프레임의 전체 개수에 변화가 없기 때문에 페이지 교체가 다른 프로세스에 영향을 미치지 않음
- 단점 : 자주 사용하는 페이지가 스왑 영역으로 옮겨져 시스템의 효율이 떨어짐

지역 교체 방식은 다른 프로세스의 스레싱은 줄일 수 있지만 반대로 실행 중인 프로세스의 성능을 떨어뜨릴 수도 있다. 전체 시스템의 입장에서는 전역 교체 방식이 지역 교체 방식보다 효율적이다.

---

### 2. 쓰기 시점 복사

데이터의 변화가 있을 때까지 복사를 미루는 방식

사용할지 안 할지 모르는 데이터를 위해 새로운 공간을 미리 만드는 낭비를 줄임

쓰기 시점 복사와 요구 페이지의 닮은 점

- 요구 페이징은 사용자가 요구할 때까지 페이지를 물리 메모리로 가져오는 것을 최대한 미룸
- 쓰기 시점 복사도 필요하다고 판단될 때까지 데이터의 복사(새로운 프레임 할당)를 최대한 미룸

![coopy-on-write](https://github.com/Butterfly-effect-19/Study_for_Beginner/blob/main/image/copy-on-write.png)

---

## 🔗 관련 문헌

- 쉽게 배우는 운영체제(한빛아카데미) - 9장
